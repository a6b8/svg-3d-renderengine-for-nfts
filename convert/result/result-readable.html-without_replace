
<!DOCTYPE html>
<html>
    <header>
    </header>
    <body>
        <svg id="2d" width="400" height="400"></svg>
        <canvas id="3d" width="400" height="400"></canvas>
        <script>class Vector3{constructor(t,e,i){this.x=t,this.y=e,this.z=i,this.w=1}}class Triangle{constructor(t,e,i,s,o,n,a,r,c){this.p0=new Vector3(t,e,i),this.p1=new Vector3(s,o,n),this.p2=new Vector3(a,r,c),this.color=0}}class Mesh{constructor(t){this.tris=[],t.forEach((t=>{let e=new Triangle(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8]);this.tris.push(e)}))}}class Mat4x4{constructor(){this.m=new Array(4).fill(0).map((()=>new Array(4).fill(0)))}}class Vector{add(t,e){return new Vector3(t.x+e.x,t.y+e.y,t.z+e.z)}sub(t,e){return new Vector3(t.x-e.x,t.y-e.y,t.z-e.z)}mul(t,e){return new Vector3(t.x*e,t.y*e,t.z*e)}div(t,e){return new Vector3(t.x/e,t.y/e,t.z/e)}dotProduct(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}length(t){return Math.sqrt(this.dotProduct(t,t))}normalise(t){const e=this.length(t);return new Vector3(t.x/e,t.y/e,t.z/e)}crossProduct(t,e){return new Vector3(t.y*e.z-t.z*e.y,t.z*e.x-t.x*e.z,t.x*e.y-t.y*e.x)}intersectPlane(t,e,i,s){e=vc.normalise(e);const o=-dotProduct(e,t),n=dotProduct(i,e),a=(-o-n)/(dotProduct(s,e)-n),r=vc.sub(s,i),c=vc.mul(r,a);return vc.add(i,c)}}class Matrix{constructor(){this.vc=new Vector}multiplyVector(t,e){const i=new Vector3;return i.x=e.x*t.m[0][0]+e.y*t.m[1][0]+e.z*t.m[2][0]+e.w*t.m[3][0],i.y=e.x*t.m[0][1]+e.y*t.m[1][1]+e.z*t.m[2][1]+e.w*t.m[3][1],i.z=e.x*t.m[0][2]+e.y*t.m[1][2]+e.z*t.m[2][2]+e.w*t.m[3][2],i.w=e.x*t.m[0][3]+e.y*t.m[1][3]+e.z*t.m[2][3]+e.w*t.m[3][3],i}makeIdentity(){const t=new Mat4x4;return t.m[0][0]=1,t.m[1][1]=1,t.m[2][2]=1,t.m[3][3]=1,t}makeRotationX(t){const e=new Mat4x4;return e.m[0][0]=1,e.m[1][1]=Math.cos(t),e.m[1][2]=Math.sin(t),e.m[2][1]=-Math.sin(t),e.m[2][2]=Math.cos(t),e.m[3][3]=1,e}makeRotationY(t){const e=new Mat4x4;return e.m[0][0]=Math.cos(t),e.m[0][2]=Math.sin(t),e.m[2][0]=-Math.sin(t),e.m[1][1]=1,e.m[2][2]=Math.cos(t),e.m[3][3]=1,e}makeRotationZ(t){const e=new Mat4x4;return e.m[0][0]=Math.cos(t),e.m[0][1]=Math.sin(t),e.m[1][0]=-Math.sin(t),e.m[1][1]=Math.cos(t),e.m[2][2]=1,e.m[3][3]=1,e}makeTranslation(t,e,i){const s=new Mat4x4;return s.m[0][0]=1,s.m[1][1]=1,s.m[2][2]=1,s.m[3][3]=1,s.m[3][0]=t,s.m[3][1]=e,s.m[3][2]=i,s}makeProjection(t,e,i,s){const o=1/Math.tan(.5*t/180*3.14159),n=new Mat4x4;return n.m[0][0]=e*o,n.m[1][1]=o,n.m[2][2]=s/(s-i),n.m[3][2]=-s*i/(s-i),n.m[2][3]=1,n.m[3][3]=0,n}multiplyMatrix(t,e){const i=new Mat4x4;for(let s=0;s<4;s++)for(let o=0;o<4;o++)i.m[o][s]=t.m[o][0]*e.m[0][s]+t.m[o][1]*e.m[1][s]+t.m[o][2]*e.m[2][s]+t.m[o][3]*e.m[3][s];return i}pointAt(t,e,i){let s=this.vc.sub(e,t);s=this.vc.normalise(s);const o=this.vc.mul(s,this.vc.dotProduct(i,s));let n=this.vc.sub(i,o);n=this.vc.normalise(n);const a=this.vc.crossProduct(n,s),r=new Mat4x4;return r.m[0][0]=a.x,r.m[0][1]=a.y,r.m[0][2]=a.z,r.m[0][3]=0,r.m[1][0]=n.x,r.m[1][1]=n.y,r.m[1][2]=n.z,r.m[1][3]=0,r.m[2][0]=s.x,r.m[2][1]=s.y,r.m[2][2]=s.z,r.m[2][3]=0,r.m[3][0]=t.x,r.m[3][1]=t.y,r}quickInverse(t){const e=new Mat4x4;return e.m[0][0]=t.m[0][0],e.m[0][1]=t.m[1][0],e.m[0][2]=t.m[2][0],e.m[0][3]=0,e.m[1][0]=t.m[0][1],e.m[1][1]=t.m[1][1],e.m[1][2]=t.m[2][1],e.m[1][3]=0,e.m[2][0]=t.m[0][2],e.m[2][1]=t.m[1][2],e.m[2][2]=t.m[2][2],e.m[2][3]=0,e.m[3][0]=-(t.m[3][0]*e.m[0][0]+t.m[3][1]*e.m[1][0]+t.m[3][2]*e.m[2][0]),e.m[3][1]=-(t.m[3][0]*e.m[0][1]+t.m[3][1]*e.m[1][1]+t.m[3][2]*e.m[2][1]),e.m[3][2]=-(t.m[3][0]*e.m[0][2]+t.m[3][1]*e.m[1][2]+t.m[3][2]*e.m[2][2]),e.m[3][3]=1,e}}function Triangle_ClipAgainstPlane(t,e,i,s,o){function n(i){a.normalise(i);return e.x*i.x+e.y*i.y+e.z*i.z-a.dotProduct(e,t)}const a=new Vector;e=a.normalise(e);let r=new Array(3).fill(new Vector3),c=0,m=new Array(3).fill(new Vector3),l=0;const h=n(i.p0),p=n(i.p1),d=n(i.p2);return h>=0?(c++,r[c]=i.p0):(l++,m[l]=i.p0),p>=0?(c++,r[c]=i.p1):(l++,m[l]=i.p1),d>=0?(c++,r[c]=i.p2):(l++,m[l]=i.p2),0==c?0:3==c?(s=i,1):1==c&&2==l?(s.color=i.color,s.p0=r[0],s.p1=a.intersectPlane(t,e,r[0],m[0]),s.p2=a.intersectPlane(t,e,r[0],m[1]),1):2==c&&1==l?(s.color=i.color,o.color=i.color,s.p0=r[0],s.p1=r[1],s.p2=a.intersectPlane(t,e,r[0],m[0]),o.p0=r[1],o.p1=s.p2,o.p2=a.intersectPlane(t,e,r[1],m[0]),2):void 0}const RenderEngine=class{constructor(){this.config={render:{loop:1,animate:10,elapse_time:.03},mesh:{file:"./version/7-class/polyhedron.obj",load_from_file:0,scale:.85,float_size:0},canvas:{width:400,height:400},camera:{position:{x:2.5,y:2,z:0},look_at:{yaw:0,distance:""}},style:{color:{background:"lightGrey"},stroke:{width:1,color:"black"},shadow:{range:200}}},this.vCamera,this.elapsedTime,this.vLookDir,this.canvas,this.svg,this.ctx}initCamera(){this.vCamera=new Vector3(this.config.camera.position.x,this.config.camera.position.y,this.config.camera.position.z),this.elapsedTime=0,this.vLookDir=new Vector3}initDom(){[["svg","2d"],["canvas","3d"]].forEach((t=>{let e=document.createElement(t[0]);e.id=t[1],e.setAttribute("width",this.config.canvas.width),e.setAttribute("height",this.config.canvas.height),document.body.appendChild(e);document.getElementById(t[1])}));this.canvas=document.getElementById("3d"),this.svg=document.getElementById("2d"),this.ctx=this.canvas.getContext("2d"),this.ctx.fillStyle=this.config.style.color.background,this.ctx.fillRect(0,0,this.config.canvas.width,this.config.canvas.height),this.ctx.lineWidth=this.config.style.stroke.width,this.ctx.strokeStyle=this.config.style.stroke.color}initEventListener(){window.addEventListener("keydown",(t=>{if(t.defaultPrevented)return;let e=0;switch(t.key){case"ArrowDown":this.config.camera.position.y-=1,e=1;break;case"ArrowUp":this.config.camera.position.y+=1,e=1;break;case"ArrowLeft":this.config.camera.position.x+=1,e=1;break;case"ArrowRight":this.config.camera.position.x-=1,e=1;break;case"w":this.config.camera.look_at.distance="forward",e=1;break;case"a":this.config.camera.look_at.yaw-=-.1,e=1;break;case"s":this.config.camera.look_at.distance="backward",e=1;break;case"d":this.config.camera.look_at.yaw+=-.1,e=1;break;default:return}this.config.render.loop||1!=e||this.renderScreen({matProj:matProj,mesh:mesh}),t.preventDefault()}),1)}meshCube(){return[[0,0,0,0,1,0,1,1,0],[0,0,0,1,1,0,1,0,0],[1,0,0,1,1,0,1,1,1],[1,0,0,1,1,1,1,0,1],[1,0,1,1,1,1,0,1,1],[1,0,1,0,1,1,0,0,1],[0,0,1,0,1,1,0,1,0],[0,0,1,0,1,0,0,0,0],[0,1,0,0,1,1,1,1,1],[0,1,0,1,1,1,1,1,0],[1,0,1,0,0,1,0,0,0],[1,0,1,0,0,0,1,0,0]]}meshLoader(t){let e=t.split("\n"),i=[],s=[];e.forEach((t=>{if(t.startsWith("v ")){let e=t.split(" ");e.shift(),e=e.map((t=>parseFloat(t))),i.push(e)}if(t.startsWith("f ")){let e=t.split(" ");e.shift(),e=e.map((t=>parseFloat(t))),s.push(e)}}));let o={x:{a:i.map((t=>t[0])),min:null,max:null,delta:null},y:{a:i.map((t=>t[1])),min:null,max:null,delta:null},z:{a:i.map((t=>t[2])),min:null,max:null,delta:null}},n=[["x","y","z"],["min","max"]];n[0].forEach((t=>{n[1].forEach((e=>{switch(e){case"min":o[t][e]=Math.min(...o[t].a);break;case"max":o[t][e]=Math.max(...o[t].a)}})),o[t].delta=o[t].max-o[t].min}));for(let t=0;t<i.length;t++)i[t][0]=(i[t][0]-o.x.min)/o.x.delta,i[t][1]=(i[t][1]-o.y.min)/o.y.delta,i[t][2]=(i[t][2]-o.z.min)/o.z.delta;return s.map((t=>[i[t[0]-1][0],i[t[0]-1][1],i[t[0]-1][2],i[t[1]-1][0],i[t[1]-1][1],i[t[1]-1][2],i[t[2]-1][0],i[t[2]-1][1],i[t[2]-1][2]]))}onUserCreate({screenHeight:t,screenWidth:e}){return(new Matrix).makeProjection(90,t/e,.1,1e3)}onUserUpdate({matProj:t,MeshCube:e,fElapsedTime:i,screenWidth:s,screenHeight:o}){const n=new Matrix,a=new Vector,r=a.mul(this.vLookDir,8*i);switch(this.config.camera.look_at.distance){case"forward":this.vCamera=a.add(this.vCamera,r),this.config.camera.look_at.distance="";break;case"backward":this.vCamera=a.sub(this.vCamera,r),this.config.camera.look_at.distance=""}const c=1*i,m=n.makeRotationZ(.5*c),l=n.makeRotationX(c);this.vCamera.x=this.config.camera.position.x,this.vCamera.y=this.config.camera.position.y;const h=n.makeTranslation(0,0,5);let p=new Mat4x4;p=n.makeIdentity(),p=n.multiplyMatrix(m,l),p=n.multiplyMatrix(p,h);const d=new Vector3(0,1,0);let u=new Vector3(0,0,1);const f=n.makeRotationY(this.config.camera.look_at.yaw);this.vLookDir=n.multiplyVector(f,u),u=a.add(this.vCamera,this.vLookDir);const w=n.pointAt(this.vCamera,u,d),g=n.quickInverse(w);let y=[];return e.tris.forEach((e=>{const i=new Triangle,r=new Triangle,c=new Triangle;r.p0=n.multiplyVector(p,e.p0),r.p1=n.multiplyVector(p,e.p1),r.p2=n.multiplyVector(p,e.p2);const m=a.sub(r.p1,r.p0),l=a.sub(r.p2,r.p0);let h=a.crossProduct(m,l);h=a.normalise(h);const d=a.sub(r.p0,this.vCamera);if(a.dotProduct(h,d)<0){let e=new Vector3(0,1,-1);e=a.normalise(e);const m=Math.max(.1,a.dotProduct(e,h));r.color=Math.floor(m*this.config.style.shadow.range),c.p0=n.multiplyVector(g,r.p0),c.p1=n.multiplyVector(g,r.p1),c.p2=n.multiplyVector(g,r.p2),c.color=r.color;const l=new Vector3(0,0,.1),p=new Vector3(0,0,1),d=new Array(2).fill(new Triangle),u=Triangle_ClipAgainstPlane(l,p,c,d[0],d[1]);for(let t=0;t<u;t++);i.p0=n.multiplyVector(t,c.p0),i.p1=n.multiplyVector(t,c.p1),i.p2=n.multiplyVector(t,c.p2),i.color=r.color,i.p0=a.div(i.p0,i.p0.w),i.p1=a.div(i.p1,i.p1.w),i.p2=a.div(i.p2,i.p2.w);const f=new Vector3(1,1,0);i.p0=a.add(i.p0,f),i.p1=a.add(i.p1,f),i.p2=a.add(i.p2,f),i.p0.x*=this.config.mesh.scale*s,i.p0.y*=this.config.mesh.scale*o,i.p1.x*=this.config.mesh.scale*s,i.p1.y*=this.config.mesh.scale*o,i.p2.x*=this.config.mesh.scale*s,i.p2.y*=this.config.mesh.scale*o;let w=[["p0","p1","p2"],["x","y","z"]];w[0].forEach((t=>{w[1].forEach((e=>{i[t][e]=Number.parseFloat(i[t][e]).toFixed(this.config.mesh.float_size)}))})),y.push(this.drawTriangleSVG(i))}})),y}drawTriangleSVG(t){return this.ctx.beginPath(),this.ctx.moveTo(t.p0.x,t.p0.y),this.ctx.lineTo(t.p1.x,t.p1.y),this.ctx.lineTo(t.p2.x,t.p2.y),this.ctx.lineTo(t.p0.x,t.p0.y),this.ctx.closePath(),this.ctx.fillStyle=`rgb(${t.color},${t.color},${t.color})`,this.ctx.stroke(),this.ctx.fill(),`<polygon points="${t.p0.x},${t.p0.y} ${t.p1.x},${t.p1.y} ${t.p2.x},${t.p2.y}" stroke="${this.config.style.stroke.color}" fill="rgb(${t.color}, ${t.color}, ${t.color})" stroke-width="${this.config.style.stroke.width}"\n        stroke-linecap="butt" stroke-linejoin="round" class="triangle" />`}renderScreen({matProj:t,mesh:e}){this.elapsedTime+=this.config.render.elapse_time,this.ctx.fillStyle=this.config.style.color.background,this.ctx.fillRect(0,0,this.config.canvas.width,this.config.canvas.height);let i=this.onUserUpdate({matProj:t,MeshCube:e,fElapsedTime:this.elapsedTime,screenWidth:this.config.canvas.width,screenHeight:this.config.canvas.height});this.svg.innerHTML=i.join("\n")}async initRender(){let t=null;if(this.config.mesh.load_from_file){const e=await fetch(this.config.mesh.file),i=await e.text();t=this.meshLoader(i)}else t=this.meshCube();const e=new Mesh(t),i=this.onUserCreate({screenHeight:this.config.canvas.height,screenWidth:this.config.canvas.width});if(this.renderScreen({matProj:i,mesh:e}),this.config.render.loop){window.setInterval((()=>{this.renderScreen({matProj:i,mesh:e})}),this.config.render.animate)}}async start(){this.initCamera(),this.initDom(),this.initEventListener(),await this.initRender()}};document.addEventListener("DOMContentLoaded",(async t=>{const e=new RenderEngine;await e.start()}));</script>
    </body>
</html>
